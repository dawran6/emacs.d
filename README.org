#+TITLE: Daw-Ran Liou's Emacs Configuration
#+STARTUP: overview
#+PROPERTY: header-args:emacs-lisp :tangle init.el :results silent

This is an ongoing evolution of my original Emacs configuration files, inspired
by a bunch of resources I’ve found online:

- https://github.com/hlissner/doom-emacs
- [[https://github.com/daviwil/dotfiles/blob/master/Emacs.org]]
- https://github.com/daviwil/emacs-from-scratch/blob/master/Emacs.org

* Table of Contents
:PROPERTIES:
:TOC:      :include all
:END:
:CONTENTS:
- [[#table-of-contents][Table of Contents]]
- [[#early-initel][Early-init.el]]
- [[#startup-performance][Startup Performance]]
  - [[#gc][GC]]
  - [[#unset-file-name-handler-alist-temporarily][Unset file-name-handler-alist temporarily]]
  - [[#measure-the-startup-time][Measure the startup time]]
- [[#keep-emacsd-clean][Keep .emacs.d Clean]]
- [[#package-system-setup][Package System Setup]]
  - [[#blackout][Blackout]]
- [[#macos][MacOS]]
- [[#keybindings][Keybindings]]
  - [[#esc-cancels-all][ESC Cancels All]]
  - [[#rebind-c-u][Rebind C-u]]
  - [[#evil][Evil]]
  - [[#keybinding-panel-which-key][Keybinding Panel (which-key)]]
  - [[#simplify-leader-bindings-generalel][Simplify Leader Bindings (general.el)]]
  - [[#better-default-bindings][Better Default Bindings]]
- [[#ui][UI]]
  - [[#clean-up-emacs-ui-to-be-more-minimal][Clean up Emacs' UI to be more minimal]]
  - [[#display-line-number][Display line number]]
  - [[#highlight-line][Highlight line]]
  - [[#theme][Theme]]
  - [[#font-configuration][Font configuration]]
  - [[#modeline][Modeline]]
  - [[#text-scaling][Text Scaling]]
  - [[#highlight-matching-parens][Highlight Matching Parens]]
  - [[#paren-face][Paren Face]]
  - [[#window-management][Window Management]]
  - [[#highlight-fill-column][Highlight Fill Column]]
  - [[#center-buffers][Center Buffers]]
  - [[#emoji-and-unicode][Emoji and Unicode]]
  - [[#native-titlebar][Native Titlebar]]
  - [[#rainbow-mode][Rainbow Mode]]
- [[#completion][Completion]]
  - [[#selectrum][Selectrum]]
  - [[#marginalia][Marginalia]]
  - [[#ctrlf][CtrlF]]
  - [[#embark][Embark]]
  - [[#consult][Consult]]
- [[#helpful-help-commands][Helpful Help Commands]]
- [[#editing][Editing]]
  - [[#tabs][Tabs]]
  - [[#commenting-lines][Commenting Lines]]
  - [[#automatically-clean-whitespace][Automatically Clean Whitespace]]
  - [[#lisp-s-expression-editing][Lisp S-expression Editing]]
  - [[#evil-multiedit][Evil Multiedit]]
  - [[#undo-fu][Undo-fu]]
  - [[#smart-parens][Smart Parens]]
  - [[#expand-region][Expand Region]]
- [[#org-mode][Org Mode]]
  - [[#basic-config][Basic Config]]
  - [[#nicer-heading-bullets][Nicer Heading Bullets]]
  - [[#auto-tangle-configuration-files][Auto-tangle Configuration Files]]
  - [[#update-table-of-contents-on-save][Update Table of Contents on Save]]
  - [[#journal][Journal]]
  - [[#roam][Roam]]
  - [[#presentation][Presentation]]
- [[#dired][Dired]]
- [[#shell][Shell]]
  - [[#exec-path][Exec-path]]
  - [[#vterm][Vterm]]
  - [[#eshell][Eshell]]
    - [[#toggling-eshell][Toggling eshell]]
- [[#development][Development]]
  - [[#projectile][Projectile]]
  - [[#magit][Magit]]
  - [[#ripgrep][Ripgrep]]
  - [[#lsp][LSP]]
    - [[#lsp-modeel-disabled][lsp-mode.el (disabled)]]
    - [[#eglot][Eglot]]
  - [[#languages][Languages]]
    - [[#clojure][Clojure]]
    - [[#markdown][Markdown]]
  - [[#company][Company]]
  - [[#syntax-checking-with-flycheck][Syntax Checking with Flycheck]]
  - [[#spell-checking-comments-and-text][Spell Checking Comments and Text]]
  - [[#eldoc][Eldoc]]
- [[#misc][Misc]]
  - [[#world-time][World Time]]
:END:

* Early-init.el

From [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][The Early Init File:]]

#+begin_quote
Most customizations for Emacs should be put in the normal init file. See Init
File. However, it is sometimes desirable to have customizations that take effect
during Emacs startup earlier than the normal init file is processed. Such
customizations can be put in the early init file, ~/.config/emacs/early-init.el
or ~/.emacs.d/early-init.el. This file is loaded before the package system and
GUI is initialized, so in it you can customize variables that affect frame
appearance as well as the package initialization process, such as
package-enable-at-startup, package-load-list, and package-user-dir.
#+end_quote

#+begin_src emacs-lisp :tangle early-init.el

  ;;; early-init.el -*- lexical-binding: t; -*-
  ;; NOTE: early-init.el is now generated from Emacs.org.  Please edit that file
  ;;       in Emacs and early-init.el will be generated automatically!

  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)
  (setq package-enable-at-startup nil)
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (setq frame-inhibit-implied-resize t)

#+end_src

* Startup Performance

Source: [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][How does Doom start up so quickly?]]

#+begin_src emacs-lisp

  ;; -*- lexical-binding: t; -*-
  ;; NOTE: init.el is now generated from Emacs.org.  Please edit that file in
  ;;       Emacs and init.el will be generated automatically!

#+end_src

** GC

The GC can easily double startup time, so we suppress it at startup by turning
up =gc-cons-threshold= (and perhaps =gc-cons-percentage=) temporarily.

#+begin_src emacs-lisp

  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)

#+end_src

However, it is important to reset it eventually. Not doing so will cause garbage
collection freezes during long-term interactive use. Conversely, a
=gc-cons-threshold= that is too small will cause stuttering. We use 16mb as our
default.

#+begin_src emacs-lisp

  (add-hook 'emacs-startup-hook
    (lambda ()
      (setq gc-cons-threshold 16777216 ; 16mb
            gc-cons-percentage 0.1)))

#+end_src

It may also be wise to raise =gc-cons-threshold= while the minibuffer is active,
so the GC doesn’t slow down expensive commands (or completion frameworks, like
helm and ivy). Here is how Doom does it:

#+begin_src emacs-lisp

  (defun doom-defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun doom-restore-garbage-collection-h ()
    ;; Defer it so that commands launched immediately after will enjoy the
    ;; benefits.
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold 16777216)))) ; 16mb

  (add-hook 'minibuffer-setup-hook #'doom-defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'doom-restore-garbage-collection-h)

#+end_src

** Unset =file-name-handler-alist= temporarily

Emacs consults this variable every time a file is read or library loaded, or
when certain functions in the file API are used (like =expand-file-name= or
=file-truename=).

Emacs does this to check if a special handler is needed to read that file, but
none of them are (typically) necessary at startup, so we disable them
(temporarily!):

#+begin_src emacs-lisp

  (defvar doom--file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)

  ;; Alternatively, restore it even later:
  (add-hook 'emacs-startup-hook
    (lambda ()
      (setq file-name-handler-alist doom--file-name-handler-alist)))

#+end_src

** Measure the startup time

#+begin_src emacs-lisp

  ;; Profile emacs startup
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))

#+end_src

* Keep .emacs.d Clean

Put backups and auto-save files in their own folders.

#+begin_src emacs-lisp

  ;; Keep backup files and auto-save files in the backups directory
  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backups" user-emacs-directory)))
        auto-save-file-name-transforms
        `((".*" ,(expand-file-name "auto-save-list/" user-emacs-directory) t)))

#+end_src

Put custom settings into its own file.

#+begin_src emacs-lisp

  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file 'noerror)

#+end_src

* Package System Setup

[[https://github.com/raxod502/straight.el][straight.el]] for reproducible package management.

#+begin_src emacs-lisp

  (setq straight-use-package-by-default t
        straight-build-dir (format "build-%s" emacs-version))

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

#+end_src

Emacs has a built in package manager but it doesn’t make it easy to automatically install packages on a new system the first time you pull down your configuration. [[https://github.com/jwiegley/use-package][use-package]] is a really helpful package used in this configuration to make it a lot easier to automate the installation and configuration of everything else we use.

#+begin_src emacs-lisp

  (straight-use-package 'use-package)
  ;;(setq use-package-always-defer t)

#+end_src

** Blackout

[[https://github.com/raxod502/blackout][Blackout]] is an easy way to turn off mode line lighters. It's similar to
diminish.el or delight.el. See the comparisons at:
https://github.com/raxod502/blackout.

#+begin_src emacs-lisp

  (use-package blackout
    :straight (:host github :repo "raxod502/blackout")
    :demand t)

  (blackout 'auto-revert-mode)

#+end_src

* MacOS

#+begin_src emacs-lisp

  (mac-auto-operator-composition-mode)

  (setq-default delete-by-moving-to-trash t)

  ;; Both command keys are 'Super'
  (setq mac-right-command-modifier 'super)
  (setq mac-command-modifier 'super)

  ;; Option or Alt is naturally 'Meta'
  (setq mac-option-modifier 'meta)
  (setq mac-right-option-modifier 'meta)

  (global-set-key (kbd "s-s") 'save-buffer)             ;; save
  (global-set-key (kbd "s-S") 'write-file)              ;; save as
  (global-set-key (kbd "s-q") 'save-buffers-kill-emacs) ;; quit
  (global-set-key (kbd "s-a") 'mark-whole-buffer)       ;; select all
  (global-set-key (kbd "s-k") 'kill-this-buffer)
  (global-set-key (kbd "s-=") 'text-scale-adjust)

#+end_src

* Keybindings

This configuration uses [[https://evil.readthedocs.io/en/latest/index.html][evil-mode]] for a Vi-like modal editing experience.
[[https://github.com/noctuid/general.el][general.el]] is used for easy keybinding configuration that integrates well with
which-key.  [[https://github.com/emacs-evil/evil-collection][evil-collection]] is used to automatically configure various Emacs
modes with Vi-like keybindings for evil-mode.

** ESC Cancels All

#+begin_src emacs-lisp

  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

** Rebind C-u

Since I let =evil-mode= take over =C-u= for buffer scrolling, I need to re-bind
the =universal-argument= command to another key sequence.  I'm choosing =C-M-u=
for this purpose.

#+begin_src emacs-lisp

  (global-set-key (kbd "C-M-u") 'universal-argument)

#+end_src

** Evil

Some tips can be found here:

- https://github.com/noctuid/evil-guide
- https://nathantypanski.com/blog/2014-08-03-a-vim-like-emacs-config.html

#+begin_src emacs-lisp

  (use-package evil
    :defer .1
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump t)
    (setq evil-move-beyond-eol t)
    (setq evil-move-cursor-back nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-normal-state-map "\C-e" 'evil-end-of-line)
    (define-key evil-insert-state-map "\C-e" 'end-of-line)
    (define-key evil-visual-state-map "\C-e" 'evil-end-of-line)
    (define-key evil-motion-state-map "\C-e" 'evil-end-of-line)
    (define-key evil-normal-state-map "\C-y" 'yank)
    (define-key evil-insert-state-map "\C-y" 'yank)
    (define-key evil-visual-state-map "\C-y" 'yank)
    (define-key evil-normal-state-map "\C-k" 'kill-line)
    (define-key evil-insert-state-map "\C-k" 'kill-line)
    (define-key evil-visual-state-map "\C-k" 'kill-line)

    ;; Get around faster
    (define-key evil-motion-state-map "gs" 'evil-avy-goto-char-timer)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal)

    (global-set-key (kbd "s-w") 'evil-window-delete))

  (use-package evil-collection
    :after evil
    :demand t
    :hook (evil-mode . evil-collection-mode)
    :config
    (evil-collection-init))

  ;; Allows you to use the selection for * and #
  (use-package evil-visualstar
    :after evil
    :hook (evil-mode . evil-visualstar-mode)
    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backward)
    :init
    (evil-define-key 'visual 'global
      "*" #'evil-visualstar/begin-search-forward
      "#" #'evil-visualstar/begin-search-backward))

#+end_src

** Keybinding Panel (which-key)

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key
binding in Emacs to offer you all possible completions for the prefix.  For
example, if you press =C-c= (hold control and press the letter =c=), a panel
will appear at the bottom of the frame displaying all of the bindings under that
prefix and which command they run.  This is very useful for learning the
possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp

  (use-package which-key
    :blackout t
    :hook (after-init . which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 1))

#+end_src

** Simplify Leader Bindings (general.el)

#+begin_src emacs-lisp

  (use-package general
    :demand t
    :config
    (general-create-definer dawran/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC")

    (general-create-definer dawran/localleader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :major-modes t
      :prefix ","
      :non-normal-prefix "C-,")

    (dawran/leader-keys
      "fd" '((lambda () (interactive) (find-file (expand-file-name "~/.emacs.d/README.org"))) :which-key "edit config")
      "t"  '(:ignore t :which-key "toggles")
      "tt" '(load-theme :which-key "choose theme")
      "tw" 'whitespace-mode
      "tm" 'toggle-frame-maximized
      "tM" 'toggle-frame-fullscreen))

#+end_src

** Better Default Bindings

#+begin_src emacs-lisp

  (global-set-key (kbd "C-x C-b") #'switch-to-buffer)
  (global-set-key (kbd "C-M-j") #'switch-to-buffer)

#+end_src

* UI
** Clean up Emacs' UI to be more minimal

#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  (setq frame-inhibit-implied-resize t)

  (setq default-frame-alist
        (append (list
                 '(font . "Monolisa-14")
                 '(min-height . 1) '(height     . 45)
                 '(min-width  . 1) '(width      . 81)
                 )))

  ;; No beeping nor visible bell
  (setq ring-bell-function #'ignore
        visible-bell nil)

  (blink-cursor-mode 0)

  (setq-default fill-column 80)
  (setq-default line-spacing 0.1)

#+end_src
** Display line number

#+begin_src emacs-lisp

  (column-number-mode)

  ;; Enable line numbers for prog modes only
  (add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode 1)))

#+end_src

** Highlight line

#+begin_src emacs-lisp

  (use-package hl-line
    :hook
    (prog-mode . hl-line-mode)
    (text-mode . hl-line-mode))

#+end_src

** Theme

I'm using my personal theme - =sketch-white= as my prefered theme.

#+begin_src emacs-lisp

  (add-to-list 'load-path "~/.emacs.d/themes")
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
  (load-theme 'sketch-black t)

#+end_src

** Font configuration

#+begin_src emacs-lisp

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Monolisa" :height 140 :weight 'regular)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Cantarell" :height 160 :weight 'regular)

#+end_src

** Modeline

NOTE: The first time you load your configuration on a new machine, you’ll need
to run =M-x all-the-icons-install-fonts= so that mode line icons display
correctly.

#+begin_src emacs-lisp

  (use-package all-the-icons
    :defer t)

  (use-package doom-modeline
    :disabled t
    :hook (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-height 15)
    (doom-modeline-lsp t)
    (doom-modeline-icon nil))

#+end_src

The simple mode line is mostly stolen from: https://github.com/raxod502/radian/blob/develop/emacs/radian.el

#+begin_src emacs-lisp

  ;;;; Mode line

  ;; The following code customizes the mode line to something like:
  ;; [*] radian.el   18% (18,0)     [radian:develop*]  (Emacs-Lisp)

  (defun my/mode-line-buffer-modified-status ()
    "Return a mode line construct indicating buffer modification status.
    This is [*] if the buffer has been modified and whitespace
    otherwise. (Non-file-visiting buffers are never considered to be
    modified.) It is shown in the same color as the buffer name, i.e.
    `mode-line-buffer-id'."
    (propertize
     (if (and (buffer-modified-p)
              (buffer-file-name))
         "[*]"
       "   ")
     'face 'mode-line-buffer-id))

  ;; Normally the buffer name is right-padded with whitespace until it
  ;; is at least 12 characters. This is a waste of space, so we
  ;; eliminate the padding here. Check the docstrings for more
  ;; information.
  (setq-default mode-line-buffer-identification
                (propertized-buffer-identification "%b"))

  ;; Make `mode-line-position' show the column, not just the row.
  (column-number-mode +1)

  ;; https://emacs.stackexchange.com/a/7542/12534
  (defun my/mode-line-align (left right)
    "Render a left/right aligned string for the mode line.
    LEFT and RIGHT are strings, and the return value is a string that
    displays them left- and right-aligned respectively, separated by
    spaces."
    (let ((width (- (window-total-width) (length left))))
      (format (format "%%s%%%ds" width) left right)))

  (defcustom my/mode-line-left
    nil
    "Composite mode line construct to be shown left-aligned."
    :type 'sexp)

  (defcustom my/mode-line-right
    '(;; Show [*] if the buffer is modified.
      (:eval (my/mode-line-buffer-modified-status))
      " "
      ;; Show the name of the current buffer.
      mode-line-buffer-identification
      " "
      ;; Show the row and column of point.
      mode-line-position
      evil-mode-line-tag
      ;; Show the active major and minor modes.
      " "
      mode-line-modes)
    "Composite mode line construct to be shown right-aligned."
    :type 'sexp)

  ;; Actually reset the mode line format to show all the things we just
  ;; defined.
  (setq-default mode-line-format
                '(:eval (replace-regexp-in-string
                         "%" "%%"
                         (my/mode-line-align
                          (format-mode-line my/mode-line-left)
                          (format-mode-line my/mode-line-right))
                         'fixedcase 'literal)))

#+end_src

** Text Scaling

#+begin_src emacs-lisp

  (use-package default-text-scale
    :defer t
    :config
    (default-text-scale-mode))

#+end_src

** Highlight Matching Parens

Display highlighting on whatever paren matches the one before or after point.

#+begin_src emacs-lisp

  (use-package paren
    :hook (prog-mode . show-paren-mode))

#+end_src

** Paren Face

[[https://github.com/tarsius/paren-face][paren-face]] dims the parentheses to reduce visual distractions.

#+begin_src emacs-lisp

  (use-package paren-face
    :hook
    (lispy-mode . paren-face-mode))

#+end_src

** Window Management
#+begin_src emacs-lisp

  (use-package ace-window
    :bind (("M-o" . ace-window))
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))

  (use-package winner-mode
    :straight nil
    :bind (:map evil-window-map
            ("u" . winner-undo)
            ("U" . winner-redo))
    :config
    (winner-mode))

  (dawran/leader-keys "w" 'evil-window-map)

#+end_src

** Highlight Fill Column

#+begin_src emacs-lisp

  (use-package hl-fill-column
    :hook (prog-mode . hl-fill-column-mode)
    :config
    (set-face-attribute 'hl-fill-column-face nil
     :background (face-attribute 'shadow :background)
     :inverse-video nil))

#+end_src

** Center Buffers

#+begin_src emacs-lisp

  (defun dawran/visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :defer t)

#+end_src

** Emoji and Unicode

#+begin_src emacs-lisp

  (use-package emojify
    :disabled
    :hook (after-init . global-emojify-mode))

  (use-package unicode-fonts
    :defer t
    :config
    (unicode-fonts-setup))

#+end_src

** Native Titlebar

#+begin_src emacs-lisp

  (use-package ns-auto-titlebar
    :hook (after-init . ns-auto-titlebar-mode))

  (setq ns-use-proxy-icon nil
        frame-title-format nil)

#+end_src

** Rainbow Mode

#+begin_src emacs-lisp

(use-package rainbow-mode
  :commands rainbow-mode)

#+end_src

* Completion
** Selectrum

- https://github.com/raxod502/selectrum

#+begin_src emacs-lisp

  (setq enable-recursive-minibuffers t)

  ;; Package `selectrum' is an incremental completion and narrowing
  ;; framework. Like Ivy and Helm, which it improves on, Selectrum
  ;; provides a user interface for choosing from a list of options by
  ;; typing a query to narrow the list, and then selecting one of the
  ;; remaining candidates. This offers a significant improvement over
  ;; the default Emacs interface for candidate selection.
  (use-package selectrum
    :straight (:host github :repo "raxod502/selectrum")
    :defer t
    :init
    ;; This doesn't actually load Selectrum.
    (selectrum-mode +1))

  ;; Package `prescient' is a library for intelligent sorting and
  ;; filtering in various contexts.
  (use-package prescient
    :config
    ;; Remember usage statistics across Emacs sessions.
    (prescient-persist-mode +1)
    ;; The default settings seem a little forgetful to me. Let's try
    ;; this out.
    (setq prescient-history-length 1000))

  ;; Package `selectrum-prescient' provides intelligent sorting and
  ;; filtering for candidates in Selectrum menus.
  (use-package selectrum-prescient
    :straight (:host github :repo "raxod502/prescient.el"
                     :files ("selectrum-prescient.el"))
    :demand t
    :after selectrum
    :config
    (selectrum-prescient-mode +1))

#+end_src

** Marginalia

#+begin_src emacs-lisp

  (use-package marginalia
    :bind (:map minibuffer-local-map
                ("C-M-a" . marginalia-cycle))
    :init
    (marginalia-mode)
    ;; When using Selectrum, ensure that Selectrum is refreshed when cycling annotations.
    (advice-add #'marginalia-cycle :after
                (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))
    (setq marginalia-annotators '(marginalia-annotators-heavy
                                  marginalia-annotators-light nil)))

#+end_src

** CtrlF

#+begin_src emacs-lisp

  ;; Package `ctrlf' provides a replacement for `isearch' that is more
  ;; similar to the tried-and-true text search interfaces in web
  ;; browsers and other programs (think of what happens when you type
  ;; ctrl+F).
  (use-package ctrlf
    :straight (:host github :repo "raxod502/ctrlf")
    :bind
    ("s-f" . ctrlf-forward-literal)

    :init

    (ctrlf-mode +1))

#+end_src

** Embark

#+begin_src emacs-lisp

  (use-package embark
    :bind
    ("C-S-a" . embark-act)

    :config
    ;; For Selectrum users:
    (defun current-candidate+category ()
      (when selectrum-active-p
        (cons (selectrum--get-meta 'category)
              (selectrum-get-current-candidate))))

    (add-hook 'embark-target-finders #'current-candidate+category)

    (defun current-candidates+category ()
      (when selectrum-active-p
        (cons (selectrum--get-meta 'category)
              (selectrum-get-current-candidates
               ;; Pass relative file names for dired.
               minibuffer-completing-file-name))))

    (add-hook 'embark-candidate-collectors #'current-candidates+category)

    ;; No unnecessary computation delay after injection.
    (add-hook 'embark-setup-hook 'selectrum-set-selected-candidate)

    :custom
    (embark-action-indicator
     (lambda (map)
       (which-key--show-keymap "Embark" map nil nil 'no-paging)
       #'which-key--hide-popup-ignore-command)
     embark-become-indicator embark-action-indicator))

#+end_src

** Consult

#+begin_src emacs-lisp

  (use-package consult
    :disabled t
    ;;:blackout t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (("C-x M-:" . consult-complex-command)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-M-j" . consult-buffer)
           ("s-b" . consult-buffer)
           ("C-x 4 b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)
           ("C-x r x" . consult-register)
           ("M-g o" . consult-outline)       ;; "M-s o" is a good alternative.
           ("M-g l" . consult-line)          ;; "M-s l" is a good alternative.
           ("M-g m" . consult-mark)          ;; I recommend to bind Consult navigation
           ("M-g k" . consult-global-mark)   ;; commands under the "M-g" prefix.
           ;;("M-g r" . consult-git-grep)      ;; or consult-grep, consult-ripgrep
           ;;("s-F" . consult-ripgrep)
           ("M-g f" . consult-find)          ;; or consult-fdfind, consult-locate
           ("M-g i" . consult-project-imenu) ;; or consult-imenu
           ("M-g e" . consult-error)
           ("M-s m" . consult-multi-occur)
           ("M-y" . consult-yank-pop)
           ("<help> a" . consult-apropos))

    :init
    ;; Replace `multi-occur' with `consult-multi-occur', which is a drop-in replacement.
    (fset 'multi-occur #'consult-multi-occur)

    :config
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    (setq consult-narrow-key "<"))

  ;; Enable Consult-Selectrum integration.
  ;; This package should be installed if Selectrum is used.
  (use-package consult-selectrum
    :disabled t
    :after selectrum
    :demand t)

  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :disabled t
    :bind (:map flycheck-command-map
                ("!" . consult-flycheck)))

#+end_src

* Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-=
command buffers.  For example, if you use =describe-function=, you will not only
get the documentation about the function, you will also see the source code of
the function and where it gets used in other places in the Emacs configuration.
It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :defer t
    :bind (;; Remap standard commands.
           ("C-h f"   . #'helpful-callable)
           ("C-h v"   . #'helpful-variable)
           ("C-h k"   . #'helpful-key)
           ("C-c C-d" . #'helpful-at-point)
           ("C-h C"   . #'helpful-command)
           ("C-h F"   . #'describe-face)))

#+end_src

* Editing
** Tabs

Default to an indentation size of 2 spaces since it’s the norm for pretty much every language I use.

#+begin_src emacs-lisp

  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  (setq-default indent-tabs-mode nil)

#+end_src

** Commenting Lines

#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))

#+end_src

** Automatically Clean Whitespace

#+begin_src emacs-lisp

  (use-package ws-butler
    :blackout t
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode))
    :custom
    ;; ws-butler normally preserves whitespace in the buffer (but strips it from
    ;; the written file). While sometimes convenient, this behavior is not
    ;; intuitive. To the average user it looks like whitespace cleanup is failing,
    ;; which causes folks to redundantly install their own.
    (ws-butler-keep-whitespace-before-point nil))

#+end_src

** Lisp S-expression Editing

I prefer to use [[https://github.com/abo-abo/lispy][lispy]] and [[https://github.com/noctuid/lispyville][lispyville]] for lisp structural editing.

#+begin_src emacs-lisp

  (use-package lispy
    :blackout t
    :hook ((emacs-lisp-mode . lispy-mode)
           (clojure-mode . lispy-mode)
           (clojurescript-mode . lispy-mode)
           (cider-repl-mode . lispy-mode))
    :custom
    (lispy-close-quotes-at-end-p t))

  (use-package lispyville
    :blackout t
    :hook ((lispy-mode . lispyville-mode))
    :custom
    (lispyville-key-theme '(operators
                            c-w
                            (prettify insert)
                            additional
                            additional-insert
                            additional-movement
                            additional-wrap
                            (atom-movement normal visual)
                            slurp/barf-cp))
    :config
    (lispy-set-key-theme '(lispy c-digits))
    (lispyville-set-key-theme))

#+end_src

** Evil Multiedit

I really like [[https://github.com/hlissner/evil-multiedit][evil-multiedit]] to do multiple cursor edits.

#+begin_src emacs-lisp

  (use-package evil-multiedit
    :defer 2
    :bind (:map evil-visual-state-map
           ("R" . evil-multiedit-match-all)
           ("M-d" . evil-multiedit-match-and-next)
           ("M-D" . evil-multiedit-match-and-prev)
           ("C-M-d" . evil-multiedit-restore)
           :map evil-normal-state-map
           ("M-d" . evil-multiedit-match-symbol-and-next)
           ("M-D" . evil-multiedit-match-symbol-and-prev)
           ("C-M-d" . evil-multiedit-restore)
           :map evil-insert-state-map
           ("M-d" . evil-multiedit-toggle-marker-here)
           :map evil-motion-state-map
           ("RET" . evil-multiedit-toggle-or-restrict-region)
           :map evil-multiedit-state-map
           ("RET" . evil-multiedit-toggle-or-restrict-region)
           ("C-n" . evil-multiedit-next)
           ("C-p" . evil-multiedit-prev)
           :map evil-multiedit-insert-state-map
           ("C-n" . evil-multiedit-next)
           ("C-p" . evil-multiedit-prev)))

#+end_src

** Undo-fu

#+begin_src emacs-lisp

  (use-package undo-fu
    :bind (:map evil-normal-state-map
           ("u" . undo-fu-only-undo)
           ("\C-r" . undo-fu-only-redo)))

#+end_src

** Smart Parens

#+begin_src emacs-lisp

  (use-package smartparens
    :blackout t
    :hook (prog-mode . smartparens-mode))

#+end_src

** Expand Region

#+begin_src emacs-lisp

  (use-package expand-region
    :bind
    ("s-'" .  er/expand-region)
    ("s-\"" .  er/contract-region))

#+end_src

* Org Mode
** Basic Config

#+begin_src emacs-lisp

  (defun dawran/org-mode-setup ()
    (org-indent-mode)
    (blackout 'org-indent-mode)
    (variable-pitch-mode 1)
    (blackout 'buffer-face-mode)
    (visual-line-mode 1)
    (blackout 'visual-line-mode)
    (dawran/visual-fill))

  (use-package org
    :hook (org-mode . dawran/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")

    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)

    (setq org-refile-targets
      '(("Archive.org" :maxlevel . 1)
        ("Tasks.org" :maxlevel . 1)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp")))

  (use-package evil-org
    :blackout t
    :after org
    :hook ((org-mode . evil-org-mode)
           (evil-org-mode . (lambda ()
                              (evil-org-set-key-theme '(navigation todo insert
                                                        textobjects
                                                        additional)))))
    :config
    (evil-org-set-key-theme))

#+end_src

** Nicer Heading Bullets

#+begin_src emacs-lisp

  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

** Auto-tangle Configuration Files

#+begin_src emacs-lisp

  (defun dawran/org-babel-tangle-config ()
    "Automatically tangle our Emacs.org config file when we save it."
    (when (string-equal (buffer-file-name)
                        (expand-file-name "./README.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'dawran/org-babel-tangle-config)))

#+end_src

** Update Table of Contents on Save

#+begin_src emacs-lisp

  (use-package org-make-toc
    :hook (org-mode . org-make-toc-mode))

#+end_src

** Journal

#+begin_src emacs-lisp

  (use-package org-journal
    :commands (org-journal-new-entry org-journal-open-current-journal-file)
    :custom
    (org-journal-date-format "%A, %d/%m/%Y")
    (org-journal-date-prefix "* ")
    (org-journal-file-format "%F.org")
    (org-journal-dir "~/org/journal/")
    (org-journal-file-type 'weekly))

  (dawran/leader-keys
    "n" '(:ignore t :which-key "notes")
    "nj" '(org-journal-new-entry :which-key "journal"))

#+end_src

** Roam

#+begin_src emacs-lisp

  (use-package org-roam
    :commands org-roam-find-file
    :custom
    (org-roam-directory "~/org/roam/")
    :config
    (dawran/leader-keys
      :keymaps 'org-roam-mode-map
      "nl" 'org-roam
      "ng" 'org-roam-graph-show
      :keymaps 'org-mode-map
      "ni" 'org-roam-insert
      "nI" 'org-roam-insert-immediate))

  (dawran/leader-keys
    "nf" 'org-roam-find-file)

#+end_src

** Presentation

#+begin_src emacs-lisp

  (use-package org-tree-slide
    :commands (org-tree-slide-mode)
    :custom
    (org-image-actual-width nil)
    (org-tree-slide-slide-in-effect nil)
    (org-tree-slide-activate-message "Presentation started.")
    (org-tree-slide-deactivate-message "Presentation ended.")
    (org-tree-slide-breadcrumbs " > ")
    (org-tree-slide-header t))

#+end_src

* Dired

#+begin_src emacs-lisp

  (use-package dired
    :straight nil
    :demand t
    :commands (dired)
    :after (evil-collection)
    :bind ("C-x C-j" . dired-jump)
    :init
    (setq dired-auto-revert-buffer t
          dired-dwim-target t)
    :config
    (setq ls-lisp-dirs-first t
          insert-directory-program "gls"
          dired-listing-switches "-agho --group-directories-first")
    (evil-collection-define-key 'normal 'dired-mode-map
      (kbd "C-c C-e") 'wdired-change-to-wdired-mode))

  (dawran/leader-keys
    "d" '(dired-jump :which-key "dired"))

  (use-package dired-x
    :after dired
    :demand t
    :straight nil
    :init (setq-default dired-omit-files-p t)
    :config
    (add-to-list 'dired-omit-extensions ".DS_Store"))

  (use-package dired-single
    :after (dired evil-collection)
    :demand t
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :after (evil-collection)
    :demand t
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))

  (use-package dired-ranger
    :after (dired evil-collection)
    :demand t
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "y" 'dired-ranger-copy
      "X" 'dired-ranger-move
      "p" 'dired-ranger-paste))

#+end_src

* Shell
** Exec-path

#+begin_src emacs-lisp

  (setq exec-path (append exec-path '("/usr/local/bin")))

#+end_src

** Vterm

#+begin_src emacs-lisp

  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000))

#+end_src

** Eshell

#+begin_src emacs-lisp

  (defun dawran/eshell-history ()
    (interactive)
    (insert (completing-read
             "Eshell history:"
             (ring-elements eshell-history-ring))))

  (defun dawran/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Use Ivy to provide completions in eshell
    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'dawran/eshell-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-a") 'eshell-bol)

    (setq eshell-history-size          10000
          eshell-buffer-maximum-lines  10000
          eshell-hist-ignoredups           t
          eshell-highlight-prompt          t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell
    :hook (eshell-first-time-mode . dawran/configure-eshell))

  (use-package exec-path-from-shell
    :defer 1
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (with-eval-after-load 'esh-opt
    (setq eshell-destroy-buffer-when-process-dies t))

  (dawran/leader-keys
    "e" 'eshell)

#+end_src

*** Toggling eshell

#+begin_src emacs-lisp

  (use-package eshell-toggle
    :custom
    (eshell-toggle-use-projectile-root t)
    (eshell-toggle-run-command nil)
    :bind
    ("C-M-'" . eshell-toggle))

#+end_src

* Development
** Projectile

#+begin_src emacs-lisp

  (use-package projectile
    :blackout t
    :commands projectile-project-name
    :custom
    (projectile-completion-system 'default)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :bind
    ("s-p" . projectile-find-file)
    :init
    (dawran/leader-keys
      "SPC" 'projectile-find-file)
    :config
    (projectile-mode))

#+end_src

** Magit

#+begin_src emacs-lisp

  (use-package magit
    :bind ("s-g" . magit-status)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (dawran/leader-keys
    "g"   '(:ignore t :which-key "git")
    "gg"  'magit-status
    "gb"  'magit-blame-addition
    "gd"  'magit-diff-unstaged
    "gf"  'magit-file-dispatch
    "gl"  'magit-log-buffer-file)

#+end_src

** Ripgrep

#+begin_src emacs-lisp

  (use-package rg
    :bind ("s-F" . rg-project)
    :after projectile
    :config
    (rg-enable-default-bindings))

#+end_src

** LSP
*** lsp-mode.el (disabled)
[[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] is currently disabled in favor of eglot mode.

#+begin_src emacs-lisp

  (use-package lsp-mode
    :disabled
    :commands lsp
    :hook ((clojure-mode . lsp)
           (clojurec-mode . lsp)
           (clojurescript-mode . lsp))
    :init
    (setq lsp-keymap-prefix "s-l")
    :config
    (lsp-enable-which-key-integration t)
    ;; add paths to your local installation of project mgmt tools, like lein
    (setenv "PATH" (concat
                     "/usr/local/bin" path-separator
                     (getenv "PATH")))
    (dolist (m '(clojure-mode
                 clojurec-mode
                 clojurescript-mode
                 clojurex-mode))
       (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
    (setq lsp-clojure-server-command '("bash" "-c" "clojure-lsp") ;; Optional: In case `clojure-lsp` is not in your PATH
          lsp-enable-indentation nil)

    (dawran/localleader-keys
      :keymaps '(clojure-mode-map clojurescript-mode-map)
      "d" 'lsp-find-definition
      "r" 'lsp-find-references))

#+end_src

*** Eglot
[[https://github.com/joaotavora/eglot][eglot]] is a client for Language Server Protocol servers in Emacs. Comparing with
lsp-mode, eglot seems to be closer-to-the metal because it chooses to work
primarily with Emacs' built-in libraries:

1. definitions can be found via =xref-find-definitions=;
2. on-the-fly diagnostics are given by =flymake-mode=;
3. function signature hints are given by =eldoc-mode=;
4. completion can be summoned with =completion-at-point=.
5. projects are discovered via =project.el='s API;

#+begin_src emacs-lisp

  (use-package eglot
    :blackout t
    :hook ((clojure-mode . eglot-ensure)
           (clojurec-mode . eglot-ensure)
           (clojurescript-mode . eglot-ensure))
    :config
    (add-to-list 'eglot-server-programs
                 '((clojure-mode clojurescript-mode) . ("bash" "-c" "/usr/local/bin/clojure-lsp")))
    (dawran/localleader-keys
      :keymaps '(clojure-mode-map clojurescript-mode-map)
      "d" 'xref-find-definitions
      "r" 'xref-find-references))

#+end_src

** Languages
*** Clojure

#+begin_src emacs-lisp

  (use-package clojure-mode
    :blackout clj-refactor-mode
    :config
    (setq clojure-indent-style 'align-arguments
          clojure-align-forms-automatically t))

  (use-package cider
    :blackout t
    :commands cider
    :config
    (setq cider-repl-display-in-current-window nil
          cider-repl-pop-to-buffer-on-connect nil
          cider-repl-use-pretty-printing t
          cider-repl-buffer-size-limit 100000
          cider-repl-result-prefix ";; => ")
    (add-hook 'cider-repl-mode-hook 'evil-insert-state)
    (evil-collection-cider-setup)
    (dawran/localleader-keys
      :keymaps '(clojure-mode-map clojurescript-mode-map)
      "e" '(:ignore t :which-key "eval")
      "eb" 'cider-eval-buffer
      "ef" 'cider-eval-defun-at-point
      "ee" 'cider-eval-last-sexp
      "t" '(:ignore t :which-key "test")
      "tt" 'cider-test-run-test
      "tn" 'cider-test-run-ns-tests))

  (dawran/localleader-keys
    :keymaps '(clojure-mode-map clojurescript-mode-map)
    "," 'cider)

  (use-package clj-refactor
    :hook (clojure-mode . clj-refactor-mode))

#+end_src

*** Markdown

#+begin_src emacs-lisp

  (use-package markdown-mode
    :mode "\\.md\\'"
    :hook (markdown-mode . dawran/visual-fill)
    :config
    (setq markdown-command "marked")
    (defun dawran/set-markdown-header-font-sizes ()
      (dolist (face '((markdown-header-face-1 . 1.2)
                      (markdown-header-face-2 . 1.1)
                      (markdown-header-face-3 . 1.0)
                      (markdown-header-face-4 . 1.0)
                      (markdown-header-face-5 . 1.0)))
        (set-face-attribute (car face) nil :weight 'normal :height (cdr face)))

    (defun dawran/markdown-mode-hook ()
      (dawran/set-markdown-header-font-sizes))

    (add-hook 'markdown-mode-hook 'dw/markdown-mode-hook)))

#+end_src

** Company

#+begin_src emacs-lisp

  (use-package company
    :disabled t
    :blackout t
    :hook (after-init . global-company-mode)
    :bind* ("M-TAB" . company-manual-begin)
    :bind (([remap completion-at-point] . #'company-manual-begin)
           ([remap complete-symbol] . #'company-manual-begin)
           (:map company-active-map
                 ("<tab>" . company-complete-selection)))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay nil)
    :config
    (add-hook 'evil-local-mode-hook
              (lambda ()
                ;; Note:
                ;; Check if `company-emulation-alist' is in
                ;; `emulation-mode-map-alists', if true, call
                ;; `company-ensure-emulation-alist' to ensure
                ;; `company-emulation-alist' is the first item of
                ;; `emulation-mode-map-alists', thus has a higher
                ;; priority than keymaps of evil-mode.
                ;; We raise the priority of company-mode keymaps
                ;; unconditionally even when completion is not
                ;; activated. This should not cause problems,
                ;; because when completion is activated, the value of
                ;; `company-emulation-alist' is ((t . company-my-keymap)),
                ;; when completion is not activated, the value is ((t . nil)).
                (when (memq 'company-emulation-alist emulation-mode-map-alists)
                  (company-ensure-emulation-alist)))))

  (use-package company-box
    :disabled t
    :blackout t
    :hook (company-mode . company-box-mode))

#+end_src

** Syntax Checking with Flycheck

#+begin_src emacs-lisp

  (use-package flycheck
    :hook (lsp-mode . flycheck-mode))

#+end_src

** Spell Checking Comments and Text

#+begin_src emacs-lisp

  (use-package flyspell
    :blackout t
    :straight nil
    :hook
    (prog-mode . flyspell-prog-mode)
    (text-mode . flyspell-mode))

#+end_src
** Eldoc

#+begin_src emacs-lisp

  (use-package eldoc
    :blackout t)

#+end_src
* Misc
** World Time

#+begin_src emacs-lisp

  (setq world-clock-list '(("Asia/Taipei" "Taipei")
                           ("America/Toronto" "Toronto")
                           ("America/Los_Angeles" "San Francisco")
                           ("Europe/Berlin" "Düsseldorf")
                           ("Europe/London" "GMT")))

  (dawran/leader-keys
    "tc" 'world-clock)

#+end_src
