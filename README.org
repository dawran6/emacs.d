#+TITLE: Daw-Ran Liou's Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

This is an ongoing evolution of my original Emacs configuration files, inspired
by a bunch of resources I’ve found online:

- https://github.com/hlissner/doom-emacs
- [[https://github.com/daviwil/dotfiles/blob/master/Emacs.org]]
- https://github.com/daviwil/emacs-from-scratch/blob/master/Emacs.org

* Table of Contents
:PROPERTIES:
:TOC:      :include all
:END:
:CONTENTS:
- [[#table-of-contents][Table of Contents]]
- [[#variables][Variables]]
- [[#gc-performance][GC Performance]]
- [[#keep-emacsd-clean][Keep .emacs.d Clean]]
- [[#package-system-setup][Package System Setup]]
- [[#keybindings][Keybindings]]
  - [[#esc-cancels-all][ESC Cancels All]]
  - [[#rebind-c-u][Rebind C-u]]
  - [[#evil][Evil]]
  - [[#keybinding-panel-which-key][Keybinding Panel (which-key)]]
  - [[#simplify-leader-bindings-generalel][Simplify Leader Bindings (general.el)]]
- [[#ui][UI]]
  - [[#clean-up-emacs-ui-to-be-more-minimal][Clean up Emacs' UI to be more minimal]]
  - [[#display-line-number][Display line number]]
  - [[#highlight-line][Highlight line]]
  - [[#theme][Theme]]
  - [[#font-configuration][Font configuration]]
  - [[#modeline][Modeline]]
  - [[#text-scaling][Text Scaling]]
  - [[#highlight-matching-parens][Highlight Matching Parens]]
  - [[#paren-face][Paren Face]]
  - [[#window-management][Window Management]]
  - [[#highlight-fill-column][Highlight Fill Column]]
  - [[#center-buffers][Center Buffers]]
  - [[#emoji-and-unicode][Emoji and Unicode]]
  - [[#native-titlebar][Native Titlebar]]
  - [[#rainbow-mode][Rainbow Mode]]
- [[#completion][Completion]]
  - [[#ivy][Ivy]]
- [[#helpful-help-commands][Helpful Help Commands]]
- [[#editing][Editing]]
  - [[#tabs][Tabs]]
  - [[#commenting-lines][Commenting Lines]]
  - [[#automatically-clean-whitespace][Automatically Clean Whitespace]]
  - [[#lisp-s-expression-editing][Lisp S-expression Editing]]
  - [[#evil-multiedit][Evil Multiedit]]
  - [[#undo-fu][Undo-fu]]
  - [[#smart-parens][Smart Parens]]
  - [[#expand-region][Expand Region]]
- [[#org-mode][Org Mode]]
  - [[#basic-config][Basic Config]]
  - [[#nicer-heading-bullets][Nicer Heading Bullets]]
  - [[#auto-tangle-configuration-files][Auto-tangle Configuration Files]]
  - [[#update-table-of-contents-on-save][Update Table of Contents on Save]]
  - [[#journal][Journal]]
  - [[#roam][Roam]]
  - [[#presentation][Presentation]]
- [[#dired][Dired]]
- [[#shell][Shell]]
  - [[#exec-path][Exec-path]]
  - [[#vterm][Vterm]]
  - [[#eshell][Eshell]]
    - [[#toggling-eshell][Toggling eshell]]
- [[#development][Development]]
  - [[#projectile][Projectile]]
  - [[#magit][Magit]]
  - [[#ripgrep][Ripgrep]]
  - [[#lsp][LSP]]
    - [[#lsp-modeel-disabled][lsp-mode.el (disabled)]]
    - [[#eglot][Eglot]]
  - [[#languages][Languages]]
    - [[#clojure][Clojure]]
    - [[#markdown][Markdown]]
  - [[#company][Company]]
  - [[#syntax-checking-with-flycheck][Syntax Checking with Flycheck]]
  - [[#spell-checking-comments-and-text][Spell Checking Comments and Text]]
- [[#misc][Misc]]
  - [[#world-time][World Time]]
:END:

* Variables

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  ;; NOTE: init.el is now generated from Emacs.org.  Please edit that file in
  ;;       Emacs and init.el will be generated automatically!

  ;; You will most likely need to adjust this font size for your system!
  (defvar dawran/default-font-size 140)
  (defvar dawran/default-variable-font-size 160)

#+end_src

* GC Performance

Source: [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][How does Doom start up so quickly?]]

The GC can easily double startup time, so we suppress it at startup by turning
up =gc-cons-threshold= (and perhaps =gc-cons-percentage=) temporarily:

#+begin_src emacs-lisp

  (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
        gc-cons-percentage 0.6)

#+end_src

However, it is important to reset it eventually. Not doing so will cause garbage
collection freezes during long-term interactive use. Conversely, a
=gc-cons-threshold= that is too small will cause stuttering. We use 16mb as our
default.

#+begin_src emacs-lisp

  (add-hook 'emacs-startup-hook
    (lambda ()
      (setq gc-cons-threshold 16777216 ; 16mb
            gc-cons-percentage 0.1)))

#+end_src

It may also be wise to raise =gc-cons-threshold= while the minibuffer is active,
so the GC doesn’t slow down expensive commands (or completion frameworks, like
helm and ivy). Here is how Doom does it:

#+begin_src emacs-lisp

  (defun doom-defer-garbage-collection-h ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun doom-restore-garbage-collection-h ()
    ;; Defer it so that commands launched immediately after will enjoy the
    ;; benefits.
    (run-at-time
     1 nil (lambda () (setq gc-cons-threshold 16777216)))) ; 16mb

  (add-hook 'minibuffer-setup-hook #'doom-defer-garbage-collection-h)
  (add-hook 'minibuffer-exit-hook #'doom-restore-garbage-collection-h)

#+end_src

Measure the startup time:

#+begin_src emacs-lisp

  ;; Profile emacs startup
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))

#+end_src

* Keep .emacs.d Clean

#+begin_src emacs-lisp

  ;; Keep backup files and auto-save files in the backups directory
  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backups" user-emacs-directory)))
        auto-save-file-name-transforms
        `((".*" ,(expand-file-name "auto-save-list/" user-emacs-directory) t)))

#+end_src

* Package System Setup

Emacs has a built in package manager but it doesn’t make it easy to automatically install packages on a new system the first time you pull down your configuration. [[https://github.com/jwiegley/use-package][use-package]] is a really helpful package used in this configuration to make it a lot easier to automate the installation and configuration of everything else we use.

#+begin_src emacs-lisp

  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
   (package-refresh-contents))

  ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
     (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)

#+end_src

* Keybindings

This configuration uses [[https://evil.readthedocs.io/en/latest/index.html][evil-mode]] for a Vi-like modal editing experience.
[[https://github.com/noctuid/general.el][general.el]] is used for easy keybinding configuration that integrates well with
which-key.  [[https://github.com/emacs-evil/evil-collection][evil-collection]] is used to automatically configure various Emacs
modes with Vi-like keybindings for evil-mode.

** ESC Cancels All

#+begin_src emacs-lisp

  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

** Rebind C-u

Since I let =evil-mode= take over =C-u= for buffer scrolling, I need to re-bind
the =universal-argument= command to another key sequence.  I'm choosing =C-M-u=
for this purpose.

#+begin_src emacs-lisp

  (global-set-key (kbd "C-M-u") 'universal-argument)

#+end_src

** Evil

Some tips can be found here:

- https://github.com/noctuid/evil-guide
- https://nathantypanski.com/blog/2014-08-03-a-vim-like-emacs-config.html

#+begin_src emacs-lisp

  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump t)
    (setq evil-move-beyond-eol t)
    (setq evil-move-cursor-back nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-normal-state-map "\C-e" 'evil-end-of-line)
    (define-key evil-insert-state-map "\C-e" 'end-of-line)
    (define-key evil-visual-state-map "\C-e" 'evil-end-of-line)
    (define-key evil-motion-state-map "\C-e" 'evil-end-of-line)
    (define-key evil-normal-state-map "\C-y" 'yank)
    (define-key evil-insert-state-map "\C-y" 'yank)
    (define-key evil-visual-state-map "\C-y" 'yank)
    (define-key evil-normal-state-map "\C-k" 'kill-line)
    (define-key evil-insert-state-map "\C-k" 'kill-line)
    (define-key evil-visual-state-map "\C-k" 'kill-line)

    ;; Get around faster
    (define-key evil-motion-state-map "gs" 'evil-avy-goto-char-timer)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal)

    (global-set-key (kbd "s-w") 'evil-window-delete))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  ;; Allows you to use the selection for * and #
  (use-package evil-visualstar
    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backward)
    :init
    (evil-define-key 'visual 'global
      "*" #'evil-visualstar/begin-search-forward
      "#" #'evil-visualstar/begin-search-backward))

#+end_src

** Keybinding Panel (which-key)

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key
binding in Emacs to offer you all possible completions for the prefix.  For
example, if you press =C-c= (hold control and press the letter =c=), a panel
will appear at the bottom of the frame displaying all of the bindings under that
prefix and which command they run.  This is very useful for learning the
possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp

  (use-package which-key
    :hook (after-init . which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 1))

#+end_src

** Simplify Leader Bindings (general.el)

#+begin_src emacs-lisp

  (use-package general
    :config
    (general-create-definer dawran/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC")

    (general-create-definer dawran/localleader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :major-modes t
      :prefix ","
      :non-normal-prefix "C-,")

    (dawran/leader-keys
      "fd" '((lambda () (interactive) (find-file (expand-file-name "~/.emacs.d/README.org"))) :which-key "edit config")
      "t"  '(:ignore t :which-key "toggles")
      "tt" '(counsel-load-theme :which-key "choose theme")
      "tw" 'whitespace-mode
      "tm" 'toggle-frame-maximized
      "tM" 'toggle-frame-fullscreen))

#+end_src

* UI
** Clean up Emacs' UI to be more minimal

#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  ;;(scroll-bar-mode -1)        ; Disable visible scrollbar
  ;;(tool-bar-mode -1)          ; Disable the toolbar
  ;;(tooltip-mode -1)           ; Disable tooltips
  ;;(set-fringe-mode 10)        ; Give some breathing room

  ;;(menu-bar-mode -1)            ; Disable the menu bar

  (setq default-frame-alist
        (append (list
	               ;;'(font . "Roboto Mono:style=Light:size=14")
	               ;;'(min-height . 1)  '(height     . 45)
	               '(min-width  . 1) '(width      . 81)
                 '(vertical-scroll-bars . nil)
                 ;;'(internal-border-width . 24)
                 ;;'(left-fringe    . 0)
                 ;;'(right-fringe   . 0)
                 '(tool-bar-lines . 0)
                 '(menu-bar-lines . 0))))

  ;; No beeping nor visible bell
  (setq ring-bell-function #'ignore
        visible-bell nil)

  (blink-cursor-mode 0)

  (setq-default fill-column 80)
  (setq-default line-spacing 0.1)

#+end_src

** Display line number

#+begin_src emacs-lisp

  (column-number-mode)

  ;; Enable line numbers for prog modes only
  (add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode 1)))

#+end_src

** Highlight line

#+begin_src emacs-lisp

  (use-package hl-line
    :ensure nil
    :hook
    (prog-mode . hl-line-mode)
    (text-mode . hl-line-mode))

#+end_src

** Theme

I'm using my personal theme - =sketch-white= as my prefered theme.

#+begin_src emacs-lisp

  (add-to-list 'load-path "~/.emacs.d/themes")
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
  (load-theme 'sketch-black t)

#+end_src

** Font configuration

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :font "Monolisa" :height dawran/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Monolisa" :height dawran/default-font-size)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Cantarell" :height dawran/default-variable-font-size :weight 'regular)

#+end_src

** Modeline

NOTE: The first time you load your configuration on a new machine, you’ll need
to run =M-x all-the-icons-install-fonts= so that mode line icons display
correctly.

#+begin_src emacs-lisp

  (use-package all-the-icons
    :defer t)

  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-height 15)
    (doom-modeline-lsp t)
    (doom-modeline-icon nil))

#+end_src

** Text Scaling

#+begin_src emacs-lisp

  (use-package default-text-scale
    :defer t
    :config
    (default-text-scale-mode))

#+end_src

** Highlight Matching Parens

Display highlighting on whatever paren matches the one before or after point.

#+begin_src emacs-lisp

  (use-package paren
    :config
    (show-paren-mode 1))

#+end_src

** Paren Face

[[https://github.com/tarsius/paren-face][paren-face]] dims the parentheses to reduce visual distractions.

#+begin_src emacs-lisp

  (use-package paren-face
    :hook
    (lispy-mode . paren-face-mode))

#+end_src

** Window Management
#+begin_src emacs-lisp

  (use-package ace-window
    :bind (("M-o" . ace-window))
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))

  (use-package winner-mode
    :ensure nil
    :bind (:map evil-window-map
            ("u" . winner-undo)
            ("U" . winner-redo))
    :config
    (winner-mode))

  (dawran/leader-keys "w" 'evil-window-map)

#+end_src

** Highlight Fill Column

#+begin_src emacs-lisp

  (use-package hl-fill-column
    :hook (prog-mode . hl-fill-column-mode)
    :config
    (set-face-attribute 'hl-fill-column-face nil
     :background (face-attribute 'shadow :background)
     :inverse-video nil))

#+end_src

** Center Buffers

#+begin_src emacs-lisp

  (defun dawran/visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :defer t)

#+end_src

** Emoji and Unicode

#+begin_src emacs-lisp

  (use-package emojify
    :hook (after-init . global-emojify-mode))

  (use-package unicode-fonts
    :defer t
    :config
    (unicode-fonts-setup))

#+end_src

** Native Titlebar

#+begin_src emacs-lisp

  (use-package ns-auto-titlebar
    :hook (after-init . ns-auto-titlebar-mode))

  (setq ns-use-proxy-icon nil
        frame-title-format nil)

#+end_src

** Rainbow Mode

#+begin_src emacs-lisp

(use-package rainbow-mode
  :commands rainbow-mode)

#+end_src

* Completion
** Ivy

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet
powerful selection menu that appears when you open files, switch buffers, and
for many other tasks in Emacs.  Counsel is a customized set of commands to
replace `find-file` with `counsel-find-file`, etc which provide useful commands
for each of the default completion commands.

#+begin_src emacs-lisp

  (use-package ivy
    :diminish
    :custom (ivy-initial-inputs-alist nil)
    :hook (after-init . ivy-mode)
    :init
    (setq ivy-re-builders-alist
          '((counsel-rg     . ivy--regex-plus)
            (swiper         . ivy--regex-plus)
            (swiper-isearch . ivy--regex-plus)
            (t              . ivy--regex-ignore-order)))
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("C-SPC" . ivy-call-and-recenter)
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    (setq ivy-count-format "(%d/%d) "
          ))

  (use-package ivy-rich
    :hook (ivy-mode . ivy-rich-mode))

  (use-package ivy-prescient
    :hook ((ivy-mode . ivy-prescient-mode)
           (ivy-prescient-mode . prescient-persist-mode))
    :custom (prescient-sort-length-enable nil))

  (use-package counsel
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-ibuffer)
           ("C-x C-f" . counsel-find-file)
           ("C-M-j" . counsel-switch-buffer)
           ("s-b" . counsel-switch-buffer)
           ("s-y" . counsel-yank-pop)
           ("s-P" . counsel-M-x)
           :map minibuffer-local-map
           ("C-r" . counsel-minibuffer-history))
    :config
    (counsel-mode 1))

  (use-package swiper
    :bind ("s-f" . swiper-isearch))

  (use-package smex ;; Adds M-x recent command sorting for counsel-M-x
    :disabled
    :defer 1
    :after counsel)

  (dawran/leader-keys
    "C-SPC" 'counsel-M-x
    "b"   '(:ignore t :which-key "buffers")
    "bb"  '(counsel-ibuffer :which-key "switch buffer")
    "bd"  '(bury-buffer :which-key "bury buffer")
    "bk"  '(kill-this-buffer :which-key "kill buffer")
    "'"   '(ivy-resume :which-key "ivy resume")
    "f"   '(:ignore t :which-key "files")
    "ff"  '(counsel-find-file :which-key "open file")
    "fr"  '(counsel-recentf :which-key "recent files")
    "fj"  '(counsel-file-jump :which-key "jump to file"))

#+end_src

* Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-=
command buffers.  For example, if you use =describe-function=, you will not only
get the documentation about the function, you will also see the source code of
the function and where it gets used in other places in the Emacs configuration.
It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ("C-h F" . counsel-describe-face)
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

* Editing
** Tabs

Default to an indentation size of 2 spaces since it’s the norm for pretty much every language I use.

#+begin_src emacs-lisp

  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  (setq-default indent-tabs-mode nil)

#+end_src

** Commenting Lines

#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))

#+end_src

** Automatically Clean Whitespace

#+begin_src emacs-lisp

  (use-package ws-butler
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode))
    :custom
    ;; ws-butler normally preserves whitespace in the buffer (but strips it from
    ;; the written file). While sometimes convenient, this behavior is not
    ;; intuitive. To the average user it looks like whitespace cleanup is failing,
    ;; which causes folks to redundantly install their own.
    (ws-butler-keep-whitespace-before-point nil))

#+end_src

** Lisp S-expression Editing

I prefer to use [[https://github.com/abo-abo/lispy][lispy]] and [[https://github.com/noctuid/lispyville][lispyville]] for lisp structural editing.

#+begin_src emacs-lisp

  (use-package lispy
    :hook ((emacs-lisp-mode . lispy-mode)
           (clojure-mode . lispy-mode)
           (clojurescript-mode . lispy-mode)
           (cider-repl-mode . lispy-mode))
    :custom
    (lispy-close-quotes-at-end-p t)
    :config
    (lispy-set-key-theme '(lispy c-digits))
    (add-hook 'lispy-mode-hook (lambda () (modify-syntax-entry ?- "w"))))

  (use-package lispyville
    :hook ((lispy-mode . lispyville-mode))
    :config
    (lispyville-set-key-theme '(operators
                                c-w
                                (prettify insert)
                                additional
                                additional-insert
                                additional-movement
                                (atom-movement normal visual)
                                slurp/barf-cp)))

#+end_src

** Evil Multiedit

I really like [[https://github.com/hlissner/evil-multiedit][evil-multiedit]] to do multiple cursor edits.

#+begin_src emacs-lisp

  (use-package evil-multiedit
    :bind (:map evil-visual-state-map
           ("R" . evil-multiedit-match-all)
           ("M-d" . evil-multiedit-match-and-next)
           ("M-D" . evil-multiedit-match-and-prev)
           ("C-M-d" . evil-multiedit-restore)
           :map evil-normal-state-map
           ("M-d" . evil-multiedit-match-symbol-and-next)
           ("M-D" . evil-multiedit-match-symbol-and-prev)
           ("C-M-d" . evil-multiedit-restore)
           :map evil-insert-state-map
           ("M-d" . evil-multiedit-toggle-marker-here)
           :map evil-motion-state-map
           ("RET" . evil-multiedit-toggle-or-restrict-region)
           :map evil-multiedit-state-map
           ("RET" . evil-multiedit-toggle-or-restrict-region)
           ("C-n" . evil-multiedit-next)
           ("C-p" . evil-multiedit-prev)
           :map evil-multiedit-insert-state-map
           ("C-n" . evil-multiedit-next)
           ("C-p" . evil-multiedit-prev)))

#+end_src

** Undo-fu

#+begin_src emacs-lisp

  (use-package undo-fu
    :bind (:map evil-normal-state-map
           ("u" . undo-fu-only-undo)
           ("\C-r" . undo-fu-only-redo)))

#+end_src

** Smart Parens

#+begin_src emacs-lisp

  (use-package smartparens
    :hook (prog-mode . smartparens-mode))

#+end_src

** Expand Region

#+begin_src emacs-lisp

  (use-package expand-region
    :bind ("s-'" .  er/mark-outside-pairs))

#+end_src

* Org Mode
** Basic Config

#+begin_src emacs-lisp

  (defun dawran/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    (dawran/visual-fill))

  (use-package org
    :hook (org-mode . dawran/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")

    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)

    (setq org-refile-targets
      '(("Archive.org" :maxlevel . 1)
        ("Tasks.org" :maxlevel . 1)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp")))

  (use-package evil-org
    :after org
    :hook ((org-mode . evil-org-mode)
           (evil-org-mode . (lambda ()
                              (evil-org-set-key-theme '(navigation todo insert
                                                        textobjects
                                                        additional)))))
    :config
    (evil-org-set-key-theme))

#+end_src

** Nicer Heading Bullets

#+begin_src emacs-lisp

  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

** Auto-tangle Configuration Files

#+begin_src emacs-lisp

  (defun dawran/org-babel-tangle-config ()
    "Automatically tangle our Emacs.org config file when we save it."
    (when (string-equal (buffer-file-name)
                        (expand-file-name "./README.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'dawran/org-babel-tangle-config)))

#+end_src

** Update Table of Contents on Save

#+begin_src emacs-lisp

  (use-package org-make-toc
    :hook (org-mode . org-make-toc-mode))

#+end_src

** Journal

#+begin_src emacs-lisp

  (use-package org-journal
    :commands (org-journal-new-entry org-journal-open-current-journal-file)
    :custom
    (org-journal-date-prefix "* ")
    (org-journal-file-format "%F.org")
    (org-journal-dir "~/org/journal/")
    (org-journal-file-type 'weekly))

  (dawran/leader-keys
    "j" '(org-journal-new-entry :which-key "journal")
    "n" '(:ignore t :which-key "notes")
    "nj" '(org-journal-open-current-journal-file :which-key "journal"))

#+end_src

** Roam

#+begin_src emacs-lisp

  (use-package org-roam
    :hook (org-mode . org-roam-mode)
    :commands (org-roam org-roam-insert org-roam-switch-to-buffer
               org-roam-find-file org-roam-graph-show org-roam-capture)
    :custom
    (org-roam-directory "~/org/roam/"))

  (dawran/leader-keys
    "nl" 'org-roam
    "ni" 'org-roam-insert
    "nb" 'org-roam-switch-to-buffer
    "nf" 'org-roam-find-file
    "ng" 'org-roam-graph-show
    "nc" 'org-roam-capture)

#+end_src

** Presentation

#+begin_src emacs-lisp

  (use-package org-tree-slide
    :commands (org-tree-slide-mode)
    :custom
    (org-image-actual-width nil)
    (org-tree-slide-slide-in-effect nil)
    (org-tree-slide-activate-message "Presentation started.")
    (org-tree-slide-deactivate-message "Presentation ended.")
    (org-tree-slide-breadcrumbs " > ")
    (org-tree-slide-header t))

#+end_src

* Dired

#+begin_src emacs-lisp

  (use-package dired
    :ensure nil
    :commands (dired)
    :bind ("C-x C-j" . dired-jump)
    :init
    (setq dired-auto-revert-buffer t
          dired-dwim-target t)
    :config
    (setq ls-lisp-dirs-first t
          insert-directory-program "gls"
          dired-listing-switches "-agho --group-directories-first")
    (evil-collection-define-key 'normal 'dired-mode-map
      (kbd "C-c C-e") 'wdired-change-to-wdired-mode))

  (dawran/leader-keys
    "d" '(dired-jump :which-key "dired"))

  (use-package dired-x
    :after dired
    :ensure nil
    :init (setq-default dired-omit-files-p t)
    :config
    (add-to-list 'dired-omit-extensions ".DS_Store"))

  (use-package dired-single
    :after dired
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))

  (use-package dired-ranger
    :after dired
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "y" 'dired-ranger-copy
      "X" 'dired-ranger-move
      "p" 'dired-ranger-paste))

#+end_src

* Shell
** Exec-path

#+begin_src emacs-lisp

  (setq exec-path (append exec-path '("/usr/local/bin")))

#+end_src

** Vterm

#+begin_src emacs-lisp

  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000))

#+end_src

** Eshell

#+begin_src emacs-lisp

  (defun dawran/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Use Ivy to provide completions in eshell
    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-a") 'eshell-bol)

    (setq eshell-history-size          10000
          eshell-buffer-maximum-lines  10000
          eshell-hist-ignoredups           t
          eshell-highlight-prompt          t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell
    :hook (eshell-first-time-mode . dawran/configure-eshell))

  (use-package exec-path-from-shell
    :defer t
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (with-eval-after-load 'esh-opt
    (setq eshell-destroy-buffer-when-process-dies t))

  (dawran/leader-keys
    "e" 'eshell)

#+end_src

*** Toggling eshell

#+begin_src emacs-lisp

  (use-package eshell-toggle
    :custom
    (eshell-toggle-use-projectile-root t)
    (eshell-toggle-run-command nil)
    :bind
    ("C-M-'" . eshell-toggle))

#+end_src

* Development
** Projectile

#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :custom
    (projectile-completion-system 'ivy)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (dawran/leader-keys
      "SPC" 'projectile-find-file)
    :config
    (projectile-mode))

  (use-package counsel-projectile
    :bind (("s-F" . counsel-projectile-rg)
           ("s-p" . counsel-projectile)))

#+end_src

** Magit

#+begin_src emacs-lisp

  (use-package magit
    :bind ("s-g" . magit-status)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (use-package evil-magit
    :after magit)

  (dawran/leader-keys
    "g"   '(:ignore t :which-key "git")
    "gg"  'magit-status
    "gb"  'magit-blame-addition
    "gd"  'magit-diff-unstaged
    "gf"  'magit-file-dispatch
    "gl"  'magit-log-buffer-file)

#+end_src

** Ripgrep

#+begin_src emacs-lisp

  (use-package rg
    :disabled
    :config
    (rg-enable-default-bindings))

#+end_src

** LSP
*** lsp-mode.el (disabled)
[[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] is currently disabled in favor of eglot mode.

#+begin_src emacs-lisp

  (use-package lsp-mode
    :disabled
    :commands lsp
    :hook ((clojure-mode . lsp)
           (clojurec-mode . lsp)
           (clojurescript-mode . lsp))
    :init
    (setq lsp-keymap-prefix "s-l")
    :config
    (lsp-enable-which-key-integration t)
    ;; add paths to your local installation of project mgmt tools, like lein
    (setenv "PATH" (concat
                     "/usr/local/bin" path-separator
                     (getenv "PATH")))
    (dolist (m '(clojure-mode
                 clojurec-mode
                 clojurescript-mode
                 clojurex-mode))
       (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
    (setq lsp-clojure-server-command '("bash" "-c" "clojure-lsp") ;; Optional: In case `clojure-lsp` is not in your PATH
          lsp-enable-indentation nil)

    (dawran/localleader-keys
      :keymaps '(clojure-mode-map clojurescript-mode-map)
      "d" 'lsp-find-definition
      "r" 'lsp-find-references))

#+end_src

*** Eglot
[[https://github.com/joaotavora/eglot][eglot]] is a client for Language Server Protocol servers in Emacs. Comparing with
lsp-mode, eglot seems to be closer-to-the metal because it chooses to work
primarily with Emacs' built-in libraries:

1. definitions can be found via =xref-find-definitions=;
2. on-the-fly diagnostics are given by =flymake-mode=;
3. function signature hints are given by =eldoc-mode=;
4. completion can be summoned with =completion-at-point=.
5. projects are discovered via =project.el='s API;

#+begin_src emacs-lisp

  (use-package eglot
    :hook ((clojure-mode . eglot-ensure)
           (clojurec-mode . eglot-ensure)
           (clojurescript-mode . eglot-ensure))
    :config
    (add-to-list 'eglot-server-programs
                 '((clojure-mode clojurescript-mode) . ("bash" "-c" "/usr/local/bin/clojure-lsp")))
    (dawran/localleader-keys
      :keymaps '(clojure-mode-map clojurescript-mode-map)
      "d" 'xref-find-definitions
      "r" 'xref-find-references))

#+end_src

** Languages
*** Clojure

#+begin_src emacs-lisp

  (use-package clojure-mode
    :defer
    :config
    (setq clojure-indent-style 'align-arguments
          clojure-align-forms-automatically t))

  (use-package cider
    :commands cider
    :config
    (setq cider-repl-display-in-current-window nil
          cider-repl-pop-to-buffer-on-connect nil
          cider-repl-use-pretty-printing t
          cider-repl-buffer-size-limit 100000
          cider-repl-result-prefix ";; => ")
    (add-hook 'cider-repl-mode-hook 'evil-insert-state)
    (evil-collection-cider-setup)
    (dawran/localleader-keys
      :keymaps '(clojure-mode-map clojurescript-mode-map)
      "e" '(:ignore t :which-key "eval")
      "eb" 'cider-eval-buffer
      "ef" 'cider-eval-defun-at-point
      "ee" 'cider-eval-last-sexp
      "t" '(:ignore t :which-key "test")
      "tt" 'cider-test-run-test
      "tn" 'cider-test-run-ns-tests))

  (dawran/localleader-keys
    :keymaps '(clojure-mode-map clojurescript-mode-map)
    "," 'cider)

  (use-package clj-refactor
    :hook (clojure-mode . clj-refactor-mode))

#+end_src

*** Markdown

#+begin_src emacs-lisp

  (use-package markdown-mode
    :mode "\\.md\\'"
    :hook (markdown-mode . dawran/visual-fill)
    :config
    (setq markdown-command "marked")
    (defun dawran/set-markdown-header-font-sizes ()
      (dolist (face '((markdown-header-face-1 . 1.2)
                      (markdown-header-face-2 . 1.1)
                      (markdown-header-face-3 . 1.0)
                      (markdown-header-face-4 . 1.0)
                      (markdown-header-face-5 . 1.0)))
        (set-face-attribute (car face) nil :weight 'normal :height (cdr face)))

    (defun dawran/markdown-mode-hook ()
      (dawran/set-markdown-header-font-sizes))

    (add-hook 'markdown-mode-hook 'dw/markdown-mode-hook)))

#+end_src

** Company

#+begin_src emacs-lisp

  (use-package company
    :hook (;(lsp-mode . company-mode)
           (eglot-managed-mode . company-mode))
    :bind (:map company-active-map
           ("<tab>" . company-complete-selection))
          (:map eglot-mode-map
           ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay nil)
    :config
    (add-hook 'evil-local-mode-hook
              (lambda ()
                ;; Note:
                ;; Check if `company-emulation-alist' is in
                ;; `emulation-mode-map-alists', if true, call
                ;; `company-ensure-emulation-alist' to ensure
                ;; `company-emulation-alist' is the first item of
                ;; `emulation-mode-map-alists', thus has a higher
                ;; priority than keymaps of evil-mode.
                ;; We raise the priority of company-mode keymaps
                ;; unconditionally even when completion is not
                ;; activated. This should not cause problems,
                ;; because when completion is activated, the value of
                ;; `company-emulation-alist' is ((t . company-my-keymap)),
                ;; when completion is not activated, the value is ((t . nil)).
                (when (memq 'company-emulation-alist emulation-mode-map-alists)
                  (company-ensure-emulation-alist)))))

  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src

** Syntax Checking with Flycheck

#+begin_src emacs-lisp

  (use-package flycheck
    :hook (lsp-mode . flycheck-mode))

#+end_src

** Spell Checking Comments and Text

#+begin_src emacs-lisp

(use-package flyspell
  :ensure nil
  :hook
  (prog-mode . flyspell-prog-mode)
  (text-mode . flyspell-mode))

#+end_src
* Misc
** World Time

#+begin_src emacs-lisp

  (setq world-clock-list '(("Asia/Taipei" "Taipei")
                           ("America/Toronto" "Toronto")
                           ("America/Los_Angeles" "San Francisco")
                           ("Europe/Berlin" "Düsseldorf")
                           ("Europe/London" "GMT")))

  (dawran/leader-keys
    "tc" 'world-clock)

#+end_src
